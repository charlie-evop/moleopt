% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mole.R
\name{run_mole}
\alias{run_mole}
\title{Execute MOLE algorithm}
\usage{
run_mole(
  fn,
  starting_points,
  max_local_sets = 1000,
  epsilon_gradient = 1e-08,
  descent_direction_min = 1e-08,
  descent_step_min = 1e-06,
  descent_step_max = 0.1,
  descent_scale_factor = 2,
  descent_armijo_factor = 1e-04,
  descent_history_size = 100L,
  descent_max_iter = 1000L,
  explore_step_min = 1e-04,
  explore_step_max = 0.1,
  explore_angle_max = 45,
  explore_scale_factor = 2,
  refine_after_nstarts = 10L,
  refine_hv_target = 2e-05,
  custom_descent_fn = NULL,
  lower = NULL,
  upper = NULL,
  max_budget = Inf,
  logging = "info"
)
}
\arguments{
\item{fn}{Bi-objective \code{smoof} function to optimize}

\item{starting_points}{Matrix of starting points to pass to MOLE}

\item{max_local_sets}{Maximum number of local sets MOLE may track}

\item{epsilon_gradient}{Epsilon used for gradient estimation}

\item{descent_direction_min}{Minimal admissible length of MO gradient}

\item{descent_step_min}{Minimal admissible step size for MO descent}

\item{descent_step_max}{Maximal admissible step size for MO descent}

\item{descent_scale_factor}{Multiplicative factor by which to scale consecutive descent steps}

\item{descent_armijo_factor}{Armijo factor utilized in line search}

\item{descent_history_size}{Size of descent history tracked for nonmonotone descent}

\item{descent_max_iter}{Maximum number of iterations per descent call}

\item{explore_step_min}{Minimal admissible step size for exploration along locally efficient set}

\item{explore_step_max}{Maximal admissible step size for exploration along locally efficient set}

\item{explore_angle_max}{Maximal admissible angle between consecutive steps for exploration along locally efficient set}

\item{explore_scale_factor}{Multiplicative factor by which to scale consecutive descent steps}

\item{refine_after_nstarts}{Number of starting points to fully evaluate before starting refinement}

\item{refine_hv_target}{Normalized Hypervolume gap target}

\item{custom_descent_fn}{Custom descent function implemented in R (optional)}

\item{lower}{Lower box constraints, if different than specified in \code{fn} (optional)}

\item{upper}{Lower box constraints, if different than specified in \code{fn} (optional)}

\item{max_budget}{Maximum budget, if budget is constrained}

\item{logging}{Logging level: \code{"none"}, \code{"debug"} or \code{"info"}}
}
\value{
List containing:
\itemize{
\item \code{sets}: Discovered locally efficient sets
\item \code{transitions}: Transitions between locally efficient sets
\item \code{budget_at_starting_points}: used budget before starting point was used
}
}
\description{
Calling \code{run_mole} executes a run of the MOLE algorithm with the given parameter setting.
}
\details{
The most important parameters to consider are:
\itemize{
\item \code{fn}: The function to optimize
\item \code{starting_points}: Pre-defined starting points for MOLE
\item \code{descent_step_max}, \code{explore_step_max}: Here it may be beneficial to deviate from the
default setting of \code{1e-1}. A reasonable choice in many situations is 1/100 of the diagonal
of the search space.
\item \code{refine_hv_target}: If post-processing for HV optimization should be used,
set this to the target value for the normalized hypervolume.
}
}
\examples{
fn <- makeAsparFunction()
starting_points <- rbind(c(1,1))
mole_trace <- run_mole(fn, starting_points)
}
